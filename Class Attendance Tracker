#!/usr/bin/env python3
import RPi.GPIO as GPIO
import time
import paho.mqtt.client as mqtt
import csv
from datetime import datetime, timedelta
import json

# ThingsBoard
Thingsboard_HOST = 'demo.thingsboard.io'
ACCESS_TOKEN_MAIN = 'Mqtv8kLjV5bbhRDUp3mv'             # per-person telemetry
ACCESS_TOKEN_TOTAL_ATTENDANCE = 'eGnEMagjPmj3NfILx0nF' # total attendance device (NEW)
ACCESS_TOKEN_DISRUPTION = 'zQ87wVhhSkHoQ2BiI6wM'      # disruption device (existing)

# Barcode attendance window
ATTENDANCE_DURATION_SECONDS = 60 * 60  # 1 hour

# --- Hardware config ---
IR_RX_PIN = 18
IR_TX_PIN = 5
LED_PIN = 12
COOLDOWN = 0.6  # seconds to ignore repeated triggers
LED_PULSE_TIME = 0.12  # seconds LED stays on per disruption

# CSV path and disruption cell location
csv_file_path = 'Barcode.csv'
DISRUPTION_ROW_INDEX = 22   # zero-based index for row 23
DISRUPTION_START_COL = 2    # zero-based index for column 3 (Day1)

# MQTT clients (one per ThingsBoard device token)
client_main = mqtt.Client(); client_main.username_pw_set(ACCESS_TOKEN_MAIN); client_main.connect(Thingsboard_HOST, 1883, 60)
client_total = mqtt.Client(); client_total.username_pw_set(ACCESS_TOKEN_TOTAL_ATTENDANCE); client_total.connect(Thingsboard_HOST, 1883, 60)
client_disruption = mqtt.Client(); client_disruption.username_pw_set(ACCESS_TOKEN_DISRUPTION); client_disruption.connect(Thingsboard_HOST, 1883, 60)

# --- Beam state ---
cnt = 0
last_time = 0.0

# --- CSV utilities that preserve whole sheet ---
def load_csv_rows():
    with open(csv_file_path, mode='r', newline='') as f:
        return list(csv.reader(f))

def save_csv_rows(rows):
    with open(csv_file_path, mode='w', newline='') as f:
        writer = csv.writer(f)
        writer.writerows(rows)

# --- Original per-person CSV handling (assumes Barcode.csv main table in top rows) ---
def load_data():
    data = {}
    with open(csv_file_path, mode='r', newline='') as file:
        reader = csv.reader(file)
        headers = next(reader)
        for row in reader:
            if not row:
                continue
            name = row[0].strip()
            barcode = row[1].strip()
            day_values = row[2:2+7]
            day_data = [int(value) if value and value.isdigit() else 0 for value in day_values]
            while len(day_data) < 7:
                day_data.append(0)
            data[barcode] = {'name': name, 'day_data': day_data}
    return data

def get_next_day(data):
    for i in range(7):
        if all((data[barcode]['day_data'][i] if i < len(data[barcode]['day_data']) else 0) == 0 for barcode in data):
            return i
    return None

def update_day_data(barcode, data, current_day):
    if barcode in data:
        while len(data[barcode]['day_data']) <= current_day:
            data[barcode]['day_data'].append(0)
        if data[barcode]['day_data'][current_day] < 1:
            data[barcode]['day_data'][current_day] += 1
            print(f"Updated {data[barcode]['name']} for Day {current_day + 1}.")
        else:
            print(f"Day {current_day + 1} for {data[barcode]['name']} is already filled.")
    else:
        print(f"Barcode {barcode} not found in the data.")

def save_data_main_table(data):
    # Overwrite the top part (main table). We'll reconstruct rows: header + per-person rows.
    rows = []
    rows.append(['Name', 'Barcode', 'Day 1', 'Day 2', 'Day 3', 'Day 4', 'Day 5', 'Day 6', 'Day 7'])
    for barcode, info in data.items():
        day_data = info['day_data'][:7] + [0] * max(0, 7 - len(info['day_data']))
        rows.append([info['name'], barcode] + day_data)
    return rows  # returned to be merged with preserved sheet

# --- Write disruption count into row 23 col (3 + current_day) preserving the rest of sheet ---
def write_disruption_to_csv_cell(disruption_count, current_day):
    rows = load_csv_rows()
    # Ensure there are at least DISRUPTION_ROW_INDEX+1 rows
    while len(rows) <= DISRUPTION_ROW_INDEX:
        rows.append([])
    target_col = DISRUPTION_START_COL + current_day
    # Ensure the target row has enough columns
    while len(rows[DISRUPTION_ROW_INDEX]) <= target_col:
        rows[DISRUPTION_ROW_INDEX].append('')
    rows[DISRUPTION_ROW_INDEX][target_col] = str(disruption_count)
    save_csv_rows(rows)

# --- Optionally append a Disruptions summary row at the end (kept for compatibility) ---
def append_disruption_summary_row(disruption_count, current_day):
    # We'll load all rows, append a final row "Disruptions" with the disruption_count in the day column
    rows = load_csv_rows()
    # Prepare a disruptions row with at least 2 + 7 columns
    disruption_row = ['Disruptions', ''] + ['']*7
    disruption_row[2 + current_day] = str(disruption_count)
    rows.append(disruption_row)
    save_csv_rows(rows)

# --- ThingsBoard publish functions ---
def publish_telemetry(data, current_day):
    telemetry_data = {}
    for barcode, info in data.items():
        value = info['day_data'][current_day] if current_day < len(info['day_data']) else 0
        telemetry_data[info['name']] = value
    payload = json.dumps(telemetry_data)
    client_main.publish('v1/devices/me/telemetry', payload)

def compute_total_count(data, current_day):
    return sum(1 for info in data.values() if (info['day_data'][current_day] if current_day < len(info['day_data']) else 0) >= 1)

def publish_total_count(total, current_day):
    payload = json.dumps({'Total Count': total, 'day': current_day + 1})
    client_total.publish('v1/devices/me/telemetry', payload)

def publish_disruption_count(disruptions, current_day):
    payload = json.dumps({'disruptions': disruptions, 'day': current_day + 1})
    client_disruption.publish('v1/devices/me/telemetry', payload)

# --- GPIO ---
def setup_gpio():
    GPIO.setmode(GPIO.BCM)
    GPIO.setup(IR_RX_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)
    GPIO.setup(IR_TX_PIN, GPIO.OUT)
    GPIO.setup(LED_PIN, GPIO.OUT)
    GPIO.output(IR_TX_PIN, GPIO.HIGH)
    GPIO.output(LED_PIN, GPIO.LOW)

def beam_callback(channel=None):
    global cnt, last_time
    now = time.time()
    if now - last_time >= COOLDOWN:
        cnt += 1
        last_time = now
        # pulse LED briefly
        GPIO.output(LED_PIN, GPIO.HIGH)
        time.sleep(LED_PULSE_TIME)
        GPIO.output(LED_PIN, GPIO.LOW)

def start_beam_detection():
    GPIO.add_event_detect(IR_RX_PIN, GPIO.FALLING, callback=beam_callback)

def stop_gpio():
    try:
        GPIO.output(IR_TX_PIN, GPIO.LOW)
    except Exception:
        pass
    try:
        GPIO.output(LED_PIN, GPIO.LOW)
    except Exception:
        pass
    GPIO.cleanup()

# --- Main ---
def main():
    data = load_data()
    current_day = get_next_day(data)
    if current_day is None:
        print("All days are filled.")
        return

    setup_gpio()
    start_beam_detection()

    print(f"Starting Day {current_day + 1}. Scan barcodes for {ATTENDANCE_DURATION_SECONDS//60} minutes or type 'exit'.")
    start_time = datetime.now()
    end_time = start_time + timedelta(seconds=ATTENDANCE_DURATION_SECONDS)

    try:
        while datetime.now() < end_time:
            scanned_data = input("Scan a barcode (or type 'exit' to finish early): ").strip()
            if scanned_data.lower() == 'exit':
                break
            if scanned_data == '':
                continue
            update_day_data(scanned_data, data, current_day)
    except KeyboardInterrupt:
        print("\nInterrupted by user.")
    finally:
        stop_gpio()
        print(f"Total disruptions (cnt) = {cnt}")

        # Write disruption count into fixed cell (row 23, col 3+current_day)
        try:
            write_disruption_to_csv_cell(cnt, current_day)
        except Exception as e:
            print("Failed writing disruption cell:", e)

        # Also append a Disruptions summary row for compatibility
        try:
            append_disruption_summary_row(cnt, current_day)
        except Exception:
            pass

        # Publish telemetry and save main table
        try:
            publish_disruption_count(cnt, current_day)
        except Exception:
            pass

        try:
            save_rows_main = save_data_main_table(data)
            # Merge main table with existing sheet while preserving rows beyond main table:
            existing_rows = load_csv_rows()
            # Replace top len(save_rows_main) rows with save_rows_main, preserve the rest
            merged_rows = save_rows_main + existing_rows[len(save_rows_main):]
            save_csv_rows(merged_rows)
        except Exception as e:
            print("Failed saving main table into CSV:", e)

        try:
            publish_telemetry(data, current_day)
        except Exception:
            pass

        try:
            total = compute_total_count(data, current_day)
            publish_total_count(total, current_day)
            print(f"Day {current_day + 1} ended. Total Count: {total}")
        except Exception:
            pass

if __name__ == "__main__":
    main()
